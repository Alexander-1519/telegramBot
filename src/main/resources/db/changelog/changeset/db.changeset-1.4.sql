insert into Questions (name, answer, category) values('Чем различаются JRE, JVM и JDK?', '
JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

JRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

JDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

Коротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для обеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java программ.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('О чем говорит ключевое слово final?', '
Модификатор final может применяться к переменным, параметрам методов, полям и методам класса или самим классам.

Класс не может иметь наследников;
Метод не может быть переопределен в классах наследниках;
Поле не может изменить свое значение после инициализации;
Параметры методов не могут изменять своё значение внутри метода;
Локальные переменные не могут быть изменены после присвоения им значения.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Какими значениями инициализируются переменные по умолчанию?', '
Числа инициализируются 0 или 0.0;
char — \u0000;
boolean — false;
Объекты (в том числе String) — null.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Какие логические операции и операторы вы знаете?', '
&: Логическое AND (И);
&&: Сокращённое AND;
|: Логическое OR (ИЛИ);
||: Сокращённое OR;
^: Логическое XOR (исключающее OR (ИЛИ));
!: Логическое унарное NOT (НЕ);
&=: AND с присваиванием;
|=: OR с присваиванием;
^=: XOR с присваиванием;
==: Равно;
!=: Не равно;
?:: Тернарный (троичный) условный оператор.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое тернарный оператор выбора?', '
Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции операторов if-then-else.

Выражение записывается в следующей форме:
условие ? выражение1 : выражение2

Если условие выполняется, то вычисляется выражение1 и его результат становится результатом выполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его значение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны возвращать значение одинакового (или совместимого) типа.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Где и для чего используется модификатор abstract?', '
Класс, помеченный модификатором abstract, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.

Метод, помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.

Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', '
Ключевое слово interface используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как public.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?', '
В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.
Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public abstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static final.
Интерфейсы позволяют создавать структуры типов без иерархии.
Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Почему в некоторых интерфейсах вообще не определяют методов?', '
Это так называемые маркерные интерфейсы. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс Clonable, который указывает на то, что класс поддерживает механизм клонирования.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Почему нельзя объявить метод интерфейса с модификатором final?', '
В случае интерфейсов указание модификатора final бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор final.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что имеет более высокий уровень абстракции - класс, абстрактный класс или интерфейс?', '
Интерфейс.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Может ли объект получить доступ к члену класса, объявленному как private? Если да, то каким образом?', '
Внутри класса доступ к приватной переменной открыт без ограничений;
Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;
Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: getX() и setX().
Через механизм рефлексии (Reflection API)
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', '
Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.

Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.

Parent static block(s) → Child static block(s) → Grandchild static block(s)
→ Parent non-static block(s) → Parent constructor →
→ Child non-static block(s) → Child constructor →
→ Grandchild non-static block(s) → Grandchild constructor
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Зачем нужны и какие бывают блоки инициализации?', '
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.

Существуют статические и нестатические блоки инициализации.
Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.
Несколько блоков инициализации выполняются в порядке следования в коде класса.
Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.
Блок инициализации возможно создать и в анонимном классе.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('К каким конструкциям Java применим модификатор static?', '
полям;
методам;
вложенным классам;
блокам инициализации;
членам секции import.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Для чего в Java используются статические блоки инициализации?', '
Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Может ли статический метод быть переопределён или перегружен?', '
Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.

Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Могут ли нестатические методы перегрузить статические?', '
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', '
При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass).
Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type.
Можно сузить возвращаемое значение, если они совместимы.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Как получить доступ к переопределенным методам родительского класса?', '
С помощью ключевого слова super мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором private.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Можно ли объявить метод абстрактным и статическим одновременно?', '
Нет. В таком случае компилятор выдаст ошибку: "Illegal combination of modifiers: ‘abstract’ and ‘static’". Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот метод будет доступен по имени класса.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('В чем разница между членом экземпляра класса и статическим членом класса?', '
Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные static инициализируются при инициализации класса. На методы, объявленные как static, накладывается ряд ограничений:
Они могут вызывать только другие статические методы.
Они должны осуществлять доступ только к статическим переменным.
Они не могут ссылаться на члены типа this или super.

В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Где разрешена инициализация статических/нестатических полей?', '
Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.
Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое Heap и Stack память в Java? Какая разница между ними?', '
Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO (Последний-зашел-Первый-вышел)

Различия между Heap и Stack памятью:

Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.
Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.
Размер памяти стека намного меньше памяти в куче.
Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?', '
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Каким образом передаются переменные в методы, по значению или по ссылке?', '
В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Для чего нужен сборщик мусора?', '
Сборщик мусора (Garbage Collector) должен делать всего две вещи:

Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
Освобождать память от мусора.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('ЧЧто такое «пул строк»?', '
Пул строк – это набор строк, хранящийся в Heap.

Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
Когда для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
При использовании оператора new создаётся новый объект String. Затем при помощи метода intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
Пул строк является примером паттерна «Приспособленец» (Flyweight).
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое finalize()? Зачем он нужен?', '
Через вызов метода finalize() (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (garbage collector) и переопределяя finalize() можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.

После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода finalize() т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.

Объект не обязательно будет доступен для сборки сразу же - метод finalize() может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Чем отличаются final, finally и finalize()?', '
Модификатор final:

Класс не может иметь наследников;
Метод не может быть переопределен в классах наследниках;
Поле не может изменить свое значение после инициализации;
Локальные переменные не могут быть изменены после присвоения им значения;
Параметры методов не могут изменять своё значение внутри метода.
Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке try-catch.

Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Расскажите про приведение типов. Что такое понижение и повышение типа?', '
Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм приведения типов (casting) - способ преобразования значения переменной одного типа в значение другого типа.

В Java существуют несколько разновидностей приведения:

Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа int было больше 127, то при приведении его к byte значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.
Расширение объектного типа (widening reference). Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException. Требует явного указания типа.
Преобразование к строке (to String). Любой тип может быть приведен к строке, т.е. к экземпляру класса String.
Запрещенные преобразования (forbidden). Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Когда в приложении может быть выброшено исключение ClassCastException?', '
ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошибке приведения типа.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое литералы?', '
Литералы — это явно заданные значения в коде программы — константы определенного типа, которые находятся в коде в момент запуска.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое autoboxing («автоупаковка») в Java и каковы правила упаковки примитивных типов в классы-обертки?', '
Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования конструктора класса.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Какие есть особенности класса String?', '
Это неизменяемый (immutable) и финализированный тип данных;
Все объекты класса String JVM хранит в пуле строк;
Объект класса String можно получить, используя двойные кавычки;
Можно использовать оператор + для конкатенации строк;
Начиная с Java 7 строки можно использовать в конструкции switch.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Почему String неизменяемый и финализированный класс?', '
Есть несколько преимуществ в неизменности строк:

Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.
Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.
Строки используются classloader и неизменность обеспечивает правильность загрузки класса.
Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его обработка происходит быстрее.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Почему char[] предпочтительнее String для хранения пароля?', '
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста. В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Почему строка является популярным ключом в HashMap в Java?', '
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа HashMap они будут обрабатываться быстрее.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Что делает метод intern() в классе String?', '
Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Какая основная разница между String, StringBuffer, StringBuilder?', '
Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.

Класс StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.

Класс StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что такое класс Object? Какие в нем есть методы?', '
Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы:

public boolean equals(Object obj) – служит для сравнения объектов по значению;

int hashCode() – возвращает hash код для объекта;

String toString() – возвращает строковое представление объекта;

Class getClass() – возвращает класс объекта во время выполнения;

protected Object clone() – создает и возвращает копию объекта;

void notify() – возобновляет поток, ожидающий монитор;

void notifyAll() – возобновляет все потоки, ожидающие монитор;

void wait() – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

void wait(long timeout) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

void wait(long timeout, int nanos) – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод notify() или notifyAll() для этого объекта;

protected void finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Дайте определение понятию «конструктор».', '
Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «конструктор по умолчанию»?', '
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».

Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Где и как вы можете использовать приватный конструктор?', '
Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Зачем нужен equals(). Чем он отличается от операции ==?', '
Метод equals() - определяет отношение эквивалентности объектов.

При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Какими свойствами обладает порождаемое equals() отношение эквивалентности?', '
Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) возвращает true.
Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают true, тогда и x.equals(z) вернёт true;
Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при условии, что никакая информация, используемая при сравнении объектов, не поменялась.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?', '
Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно обязательно переопределять и метод hashCode().
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?', '
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Для чего нужен метод hashCode()?', '
Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:

если хэш коды разные, то и объекты гарантированно разные;
если хэш коды равны, то объекты не обязательно равны(могут быть разные).
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?', '
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Могут ли у разных объектов быть одинаковые hashCode()?', '
Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Расскажите про клонирование объектов.', '
Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта.

Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод clone() как public для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода super.clone(), которая и выполняет собственно клонирование.

Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.

Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.

Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений final для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('В чем отличие между поверхностным и глубоким клонированием?', '
Поверхностное копирование копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс Object не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам:
Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

Глубокое копирование дублирует абсолютно всю информацию объекта:
Нет необходимости копировать отдельно примитивные данные;
Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода clone() должен вызываться super.clone();
Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
', 'QUESTION_BASIC');

insert into Questions (name, answer, category) values('Опишите иерархию исключений.', '
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, потомками которого являются классы Exception и Error.

Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Что такое checked и unchecked exception?', '
В Java все исключения делятся на два типа:

checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или описываться в заголовке метода (например, throws IOException). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;
unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки Error (например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом RuntimeException и его наследниками (например, NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в заголовке метода.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Какой оператор позволяет принудительно выбросить исключение?', '
Это оператор throw:
throw new Exception();
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('О чем говорит ключевое слово throws?', '
Модификатор throws прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Как написать собственное («пользовательское») исключение?', '
Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException).
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Какие существуют unchecked exception?', '
Наиболее часто встречающиеся: ArithmeticException, ClassCastException, ConcurrentModificationException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, NoSuchElementException, NullPointerException, UnsupportedOperationException.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Что представляет из себя ошибки класса Error?', '
Ошибки класса Error представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Что вы знаете о OutOfMemoryError?', '
OutOfMemoryError выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Опишите работу блока try-catch-finally.', '
try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет.

Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:

try {
    //код, который потенциально может привести к исключительной ситуации
}
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки
    //код обработки исключительной ситуации
}
finally {
    //необязательный блок, код которого выполняется в любом случае
}
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Что такое механизм try-with-resources?', '
Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс java.lang.Autocloseable.

Общий вид конструкции:

try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Возможно ли использование блока try-finally (без catch)?', '
Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок catch, в котором будет обрабатываться необходимое исключение.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Может ли один блок catch отлавливать сразу несколько исключений?', '
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:

try {
    //...
} catch(IOException | SQLException ex) {
    //...
}
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Всегда ли исполняется блок finally?', '
Код в блоке finally будет выполнен всегда, независимо от того, выброшено исключение или нет.
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Существуют ли ситуации, когда блок finally не будет выполнен?', '
Например, когда JVM «умирает» - в такой ситуации finally недостижим и не будет выполнен, так как происходит принудительный системный выход из программы:

try {
    System.exit(0);
} catch(Exception e) {
    e.printStackTrace();
} finally { }
', 'QUESTION_EXCEPTIONS');

insert into Questions (name, answer, category) values('Что такое generics?', '
Generics - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.

Примером использования обобщенных типов может служить Java Collection Framework. Так, класс LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа LinkedList<String>, LinkedList<Integer> и т.п.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Что такое ООП?', '
Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
каждый объект является экземпляром определенного класса
классы образуют иерархии.
Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Назовите основные принципы ООП.', '
Инкапсуляция - сокрытие реализации.
Наследование - создание новой сущности на базе уже существующей.
Полиморфизм - возможность иметь разные формы для одной и той же сущности.
Абстракция - набор общих характеристик.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «инкапсуляция»?', '
Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «наследование»?', '
Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется предком, базовым или родительским. Новый класс – потомком, наследником или производным классом.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «полиморфизм»?', '
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «абстракция»?', '
Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Расскажите про основные понятия ООП: «класс», «объект», «интерфейс».', '
Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

С точки зрения структуры программы, класс является сложным типом данных.

Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.

Интерфейс – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что подразумевают в плане принципов ООП выражения «является» и «имеет»?', '
«является» подразумевает наследование. «имеет» подразумевает ассоциацию (агрегацию или композицию).
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('В чем разница между композицией и агрегацией?', '
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».

Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое статическое и динамическое связывание?', '
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).

В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как final (приватные методы являются final по умолчанию).
', 'QUESTION_OOP');

insert into Questions (name, answer, category) values('Что такое «коллекция»?', '
«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Почему Map — это не Collection, в то время как List и Set являются Collection?', '
Collection представляет собой совокупность некоторых элементов. Map - это совокупность пар «ключ-значение».
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('В чем разница между классами java.util.Collection и java.util.Collections?', '
java.util.Collections - набор статических методов для работы с коллекциями.

java.util.Collection - один из основных интерфейсов Java Collections Framework.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Чем различаются Enumeration и Iterator.', '
Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:

с помощью Enumeration нельзя добавлять/удалять элементы;
в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);
Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Как между собой связаны Iterable и Iterator?', '
Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Что произойдет при вызове Iterator.next() без предварительного вызова Iterator.hasNext()?', '
Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возвращен следующий элемент.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Как поведёт себя коллекция, если вызвать iterator.remove()?', '
Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено IllegalStateException().
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Какая коллекция реализует дисциплину обслуживания FIFO?', '
FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция Queue.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Какая коллекция реализует дисциплину обслуживания FILO?', '
FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция Stack.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?', '
ArrayList это список, реализованный на основе массива, а LinkedList — это классический двусвязный список, основанный на объектах с ссылками между ними.

ArrayList:

доступ к произвольному элементу по индексу за константное время O(1);
доступ к элементам по значению за линейное время O(N);
вставка в конец в среднем производится за константное время O(1);
удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;
минимум накладных расходов при хранении.
LinkedList:

на получение элемента по индексу или значению потребуется линейное время O(N);
но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1) — ссылки постоянно хранятся на первый и последний элемент;
на добавление и удаление в начало или конец списка потребуется константное O(1);
вставка или удаление в/из произвольного место константное O(1);
но поиск позиции вставки и удаления за линейное время O(N);
требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.
В целом, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти, и по скорости выполнения операций. LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.
', 'QUESTION_COLLECTIONS');

insert into Questions (name, answer, category) values('Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?', '
При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой trimToSize().
', 'QUESTION_COLLECTIONS');